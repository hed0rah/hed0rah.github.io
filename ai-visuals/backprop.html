<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Backpropagation</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Bebas+Neue&display=swap');
:root {
  --bg:        #0a0a0a;
  --surface:   #111111;
  --surface2:  #0d0d0d;
  --border:    #1e1e1e;
  --border2:   #2a2a2a;
  --cyan:      #00ffe9;
  --yellow:    #ffe900;
  --magenta:   #e900ff;
  --red:       #ff2d55;
  --green:     #39ff14;
  --orange:    #ff6b00;
  --dim:       #3a3a3a;
  --text:      #cccccc;
  --bright:    #ffffff;
  --fwd:       #00ffe9;
  --bwd:       #ff2d55;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{background:var(--bg);color:var(--text);font-family:'Space Mono',monospace;font-size:11px;line-height:1.65;padding:36px 30px;max-width:980px;margin:0 auto;}
body::before{content:'';position:fixed;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.04) 2px,rgba(0,0,0,0.04) 4px);pointer-events:none;z-index:999;}
.masthead{border-top:3px solid var(--red);padding:14px 0 10px;margin-bottom:28px;display:flex;justify-content:space-between;align-items:flex-end;border-bottom:1px solid var(--border);}
.masthead h1{font-family:'Bebas Neue',sans-serif;font-size:64px;letter-spacing:4px;color:var(--bright);line-height:1;}
.masthead h1 em{color:var(--red);font-style:normal;}
.masthead-right{text-align:right;font-size:10px;color:#444;letter-spacing:2px;text-transform:uppercase;}
.masthead-right strong{display:block;color:var(--cyan);font-size:11px;margin-bottom:2px;}
.g2{display:grid;grid-template-columns:1fr 1fr;gap:2px;margin-bottom:2px;}
.gfull{margin-bottom:2px;}
.panel{background:var(--surface);border:1px solid var(--border);padding:18px;}
.plabel{font-family:'Bebas Neue',sans-serif;font-size:10px;letter-spacing:3px;color:#383838;text-transform:uppercase;margin-bottom:10px;padding-bottom:6px;border-bottom:1px solid var(--border);}
.ptitle{font-family:'Bebas Neue',sans-serif;font-size:26px;letter-spacing:2px;color:var(--bright);margin-bottom:8px;line-height:1;}
.ptitle.cy{color:var(--cyan);}.ptitle.rd{color:var(--red);}.ptitle.yl{color:var(--yellow);}.ptitle.pu{color:var(--magenta);}.ptitle.or{color:var(--orange);}.ptitle.gr{color:var(--green);}
.bar{width:28px;height:2px;margin-bottom:10px;background:var(--cyan);}
.bar.rd{background:var(--red);}.bar.yl{background:var(--yellow);}
p{font-size:11px;color:var(--text);margin-bottom:7px;line-height:1.65;}
.hl{color:var(--cyan);font-weight:700;}.hl.rd{color:var(--red);}
.math-block{background:#060606;border:1px solid var(--border);border-left:3px solid var(--yellow);padding:12px 14px;margin:10px 0;font-size:11px;}
.eq{color:var(--yellow);}
.tag{display:inline-block;border:1px solid var(--border);padding:1px 6px;font-size:9px;letter-spacing:1px;text-transform:uppercase;color:#444;margin:2px 2px 2px 0;}
.tag.cy{border-color:var(--cyan);color:var(--cyan);}.tag.rd{border-color:var(--red);color:var(--red);}
.annotation{margin-top:8px;padding-left:10px;border-left:2px solid var(--red);font-size:10px;font-style:italic;color:var(--dim);}

/* net canvas layout */
.net-wrap{display:grid;grid-template-columns:1fr 220px;gap:2px;margin-top:12px;}
canvas#netCanvas{width:100%;height:320px;display:block;background:#060606;}
.side-stack{display:flex;flex-direction:column;gap:2px;}
.panel-head{background:var(--border2);color:var(--dim);font-size:9px;letter-spacing:2px;text-transform:uppercase;padding:5px 10px;border-bottom:1px solid var(--border);}
.panel-body{padding:8px 10px;}
.data-row{display:flex;justify-content:space-between;align-items:center;padding:3px 0;border-bottom:1px solid var(--border);font-size:10px;}
.data-row:last-child{border-bottom:none;}
.data-key{color:var(--dim);}
.data-val{font-weight:700;font-variant-numeric:tabular-nums;}
.data-val.fwd{color:var(--fwd);}
.data-val.bwd{color:var(--bwd);}
.btn-row{display:flex;gap:2px;}
button{font-family:'Space Mono',monospace;font-size:9px;letter-spacing:2px;text-transform:uppercase;padding:7px 10px;border:none;background:var(--surface2);color:var(--dim);cursor:pointer;flex:1;transition:all 0.1s;}
button:hover{background:var(--border2);color:var(--bright);}
button.active-fwd{background:var(--fwd);color:var(--bg);}
button.active-bwd{background:var(--bwd);color:var(--bright);}
.step-hint{padding:6px 10px;font-size:10px;color:var(--dim);background:var(--surface);border-top:1px solid var(--border);min-height:28px;}

/* chain rule */
.chain-line{display:flex;align-items:center;gap:8px;flex-wrap:wrap;padding:6px 10px;border-bottom:1px solid var(--border);opacity:0;transform:translateX(-8px);transition:opacity 0.35s,transform 0.35s;font-size:11px;}
.chain-line.visible{opacity:1;transform:translateX(0);}
.chain-line:last-child{border-bottom:none;}
.chain-label{font-size:9px;letter-spacing:2px;text-transform:uppercase;color:var(--dim);min-width:90px;}
.math{font-style:italic;color:var(--fwd);}
.math.partial{color:var(--bwd);}
.times{color:var(--dim);margin:0 2px;}
.c-tag{font-size:9px;color:var(--dim);margin-left:auto;white-space:nowrap;}
.chain-highlight{background:rgba(255,45,85,0.05);border-left:2px solid var(--bwd)!important;}
.update-box{margin-top:10px;padding:10px 14px;border:1px solid var(--border2);background:#060606;font-size:11px;}

/* loss canvas */
canvas#lossCanvas{width:100%;height:180px;display:block;background:#060606;}
.train-controls{display:flex;gap:2px;}
.epoch-track{padding:6px 10px;background:var(--surface);border-bottom:1px solid var(--border);font-size:10px;color:var(--dim);}
.epoch-bar-wrap{height:3px;background:var(--border2);margin-top:4px;}
.epoch-bar-fill{height:100%;background:var(--bwd);transition:width 0.1s;width:0%;}

/* glossary */
.concepts{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:2px;margin-top:10px;}
.concept-card{background:var(--surface);border:1px solid var(--border);padding:14px;}
.concept-name{font-family:'Bebas Neue',sans-serif;font-size:16px;letter-spacing:2px;margin-bottom:6px;}
.concept-name.cy{color:var(--cyan);}.concept-name.rd{color:var(--red);}.concept-name.yl{color:var(--yellow);}.concept-name.gr{color:var(--green);}.concept-name.pu{color:var(--magenta);}
.concept-def{font-size:10px;line-height:1.65;color:var(--text);}
.formula-block{margin-top:6px;padding:4px 8px;border-left:2px solid var(--border2);font-size:10px;font-style:italic;color:var(--fwd);background:var(--bg);}

.footer{border-top:1px solid var(--border);margin-top:14px;padding-top:10px;display:flex;justify-content:space-between;font-size:9px;color:#2a2a2a;letter-spacing:1px;}
@media(max-width:700px){.net-wrap{grid-template-columns:1fr;}.g2{grid-template-columns:1fr;}}
</style>
</head>
<body>

<div class="masthead">
  <h1>BACK<em>PROP</em><br>AGATION</h1>
  <div class="masthead-right">
    <strong>GRADIENT-BASED CREDIT ASSIGNMENT</strong>
    CHAIN RULE // COMPUTATIONAL GRAPHS<br>
    FORWARD PASS // BACKWARD PASS
  </div>
</div>

<div class="gfull">
  <div class="panel">
    <div class="plabel">01 // Concept</div>
    <div class="ptitle rd">THE BIG PICTURE</div>
    <div class="bar rd"></div>
    <p>A neural network makes a prediction. It's wrong. The question is: <strong>which weights caused this wrongness, and by how much?</strong> Backpropagation is the systematic answer — an efficient application of the chain rule of calculus that assigns blame to every single weight in the network proportionally to its contribution to the error.</p>
    <p>The forward pass computes a prediction. The loss function measures how bad it is. Then backprop runs the signal in reverse — from output back to input — computing the gradient of the loss with respect to every parameter. Gradient descent then nudges each weight in the direction that reduces loss. Repeat millions of times. That is training.</p>
    <p class="annotation">"Backprop is just the chain rule applied recursively. The insight was realizing you could cache intermediate computations and reuse them — making it O(n) instead of O(n²)."</p>
  </div>
</div>

<div class="gfull">
  <div class="panel">
    <div class="plabel">02 // Visualization</div>
    <div class="ptitle cy">FORWARD + BACKWARD PASS</div>
    <div class="bar"></div>
    <p>A tiny network: 2 inputs, one hidden layer of 3 neurons (ReLU), 1 output (sigmoid). Step through the forward pass to see activations propagate, then watch gradients flow backward. Edge thickness encodes magnitude.</p>
    <div class="net-wrap">
      <canvas id="netCanvas"></canvas>
      <div class="side-stack">
        <div class="panel" style="padding:0;">
          <div class="panel-head">Node Values</div>
          <div class="panel-body">
            <div class="data-row"><span class="data-key">x1 (input)</span><span class="data-val fwd" id="v-x1">0.80</span></div>
            <div class="data-row"><span class="data-key">x2 (input)</span><span class="data-val fwd" id="v-x2">0.20</span></div>
            <div class="data-row"><span class="data-key">h1 (pre-act)</span><span class="data-val fwd" id="v-h1pre">—</span></div>
            <div class="data-row"><span class="data-key">h1 (post-ReLU)</span><span class="data-val fwd" id="v-h1">—</span></div>
            <div class="data-row"><span class="data-key">h2 (post-ReLU)</span><span class="data-val fwd" id="v-h2">—</span></div>
            <div class="data-row"><span class="data-key">h3 (post-ReLU)</span><span class="data-val fwd" id="v-h3">—</span></div>
            <div class="data-row"><span class="data-key">output (sigmoid)</span><span class="data-val fwd" id="v-out">—</span></div>
            <div class="data-row"><span class="data-key">target</span><span class="data-val" style="color:var(--text);">1.00</span></div>
            <div class="data-row"><span class="data-key">BCE loss</span><span class="data-val bwd" id="v-loss">—</span></div>
          </div>
        </div>
        <div class="panel" style="padding:0;">
          <div class="panel-head">Gradients (dL/dW)</div>
          <div class="panel-body">
            <div class="data-row"><span class="data-key">dL/d(output)</span><span class="data-val bwd" id="g-out">—</span></div>
            <div class="data-row"><span class="data-key">dL/dW_out[0]</span><span class="data-val bwd" id="g-w0">—</span></div>
            <div class="data-row"><span class="data-key">dL/dW_out[1]</span><span class="data-val bwd" id="g-w1">—</span></div>
            <div class="data-row"><span class="data-key">dL/dW_out[2]</span><span class="data-val bwd" id="g-w2">—</span></div>
            <div class="data-row"><span class="data-key">dL/dh1</span><span class="data-val bwd" id="g-h1">—</span></div>
          </div>
        </div>
        <div class="btn-row">
          <button id="btnFwd">Forward</button>
          <button id="btnBwd">Backprop</button>
          <button id="btnReset">Reset</button>
        </div>
        <div class="step-hint" id="stepHint">Click FORWARD to begin.</div>
      </div>
    </div>
  </div>
</div>

<div class="gfull">
  <div class="panel">
    <div class="plabel">03 // Mathematics</div>
    <div class="ptitle yl">THE CHAIN RULE, UNROLLED</div>
    <div class="bar yl"></div>
    <p>To find how much a weight in layer 1 affects the loss, trace every path from that weight to the output and multiply local derivatives along the way. Every node owns just its local gradient — backprop does the rest by accumulation.</p>
    <div style="background:#060606;border:1px solid var(--border);margin-top:10px;" id="chainContainer">
      <div class="chain-line" id="c0"><span class="chain-label">Loss fn</span><span>L = -[ y·log(ŷ) + (1-y)·log(1-ŷ) ]</span><span class="c-tag">Binary Cross-Entropy</span></div>
      <div class="chain-line" id="c1"><span class="chain-label">dL/dŷ</span><span class="math partial">= -(y/ŷ) + (1-y)/(1-ŷ)</span></div>
      <div class="chain-line" id="c2"><span class="chain-label">dŷ/dz_out</span><span class="math">= σ(z) · (1 - σ(z))</span><span class="c-tag">sigmoid derivative</span></div>
      <div class="chain-line" id="c3"><span class="chain-label">dz_out/dw_i</span><span class="math">= h_i</span><span class="c-tag">output layer weight grad</span></div>
      <div class="chain-line chain-highlight" id="c4"><span class="chain-label" style="color:var(--bwd);">dL/dw_i</span><span class="math partial">dL/dŷ</span><span class="times">×</span><span class="math">dŷ/dz_out</span><span class="times">×</span><span class="math">dz_out/dw_i</span><span class="c-tag" style="color:var(--bwd);">CHAIN RULE</span></div>
      <div class="chain-line" id="c5"><span class="chain-label">dL/dh_i</span><span class="math partial">= dL/dz_out</span><span class="times">×</span><span class="math">w_i</span><span class="c-tag">propagate back to hidden</span></div>
      <div class="chain-line" id="c6"><span class="chain-label">ReLU grad</span><span class="math">dh_i/dz_i = 1 if z_i &gt; 0, else 0</span><span class="c-tag">gate: zero if pre-act negative</span></div>
      <div class="chain-line" id="c7"><span class="chain-label">dL/dw1_ij</span><span class="math partial">= dL/dh_i</span><span class="times">×</span><span class="math">dh_i/dz_i</span><span class="times">×</span><span class="math">x_j</span><span class="c-tag">hidden layer weight grad</span></div>
    </div>
    <div class="update-box">
      <strong>Weight update:</strong> <span class="math">w := w - η · dL/dw</span><br>
      <span style="font-size:10px;color:var(--dim);">where η is the learning rate — step size in parameter space per iteration.</span>
    </div>
  </div>
</div>

<div class="gfull">
  <div class="panel">
    <div class="plabel">04 // Training Dynamics</div>
    <div class="ptitle rd">LOSS OVER TIME</div>
    <div class="bar rd"></div>
    <p>Each backprop + weight update cycle should decrease the loss — we're descending the gradient. The loss curve reveals the health of training. Click <strong>Run Training</strong> to simulate 200 gradient descent steps.</p>
    <div style="margin-top:10px;">
      <div class="train-controls">
        <button id="btnTrain" style="flex:none;padding:8px 18px;">Run Training</button>
        <button id="btnResetTrain" style="flex:none;padding:8px 18px;">Reset</button>
        <div style="flex:1;background:var(--surface);display:flex;align-items:center;padding:0 12px;font-size:10px;color:var(--dim);" id="epochLabel">—</div>
      </div>
      <div class="epoch-track">
        <div style="display:flex;justify-content:space-between;"><span>Epoch 0</span><span>Epoch 200</span></div>
        <div class="epoch-bar-wrap"><div class="epoch-bar-fill" id="epochBar"></div></div>
      </div>
      <canvas id="lossCanvas"></canvas>
      <div style="padding:6px 10px;background:var(--surface);font-size:10px;color:var(--dim);border-top:1px solid var(--border);">
        Final prediction: <span style="color:var(--fwd);font-weight:700;" id="finalPred">—</span>
        <span style="margin-left:12px;">Target: <span style="color:var(--green);">1.0000</span></span>
      </div>
    </div>
  </div>
</div>

<div class="gfull">
  <div class="panel">
    <div class="plabel">05 // Glossary</div>
    <div class="ptitle">CORE CONCEPTS</div>
    <div class="bar yl"></div>
    <div class="concepts">
      <div class="concept-card"><div class="concept-name rd">Computational Graph</div><div class="concept-def">A directed acyclic graph where nodes are operations and edges carry values. Backprop traverses this graph in reverse topological order, accumulating gradients at each node via the chain rule.</div></div>
      <div class="concept-card"><div class="concept-name cy">Local Gradient</div><div class="concept-def">The derivative of a node's output with respect to its own input, computed independently of the rest of the graph. Each node multiplies incoming upstream gradient by its local gradient to produce the outgoing signal.</div><div class="formula-block">∂out/∂in (at a single node)</div></div>
      <div class="concept-card"><div class="concept-name gr">Vanishing Gradient</div><div class="concept-def">When gradients shrink as they propagate backward through many layers, eventually becoming so small that early layers receive near-zero signal and stop learning. Caused by activations like sigmoid whose derivatives are less than 1.</div></div>
      <div class="concept-card"><div class="concept-name yl">Learning Rate η</div><div class="concept-def">Scalar controlling step size in weight space. Too large: oscillates or diverges. Too small: trains glacially. Adaptive methods like Adam adjust it per-parameter dynamically based on gradient history.</div><div class="formula-block">w &lt;- w - η · ∂L/∂w</div></div>
      <div class="concept-card"><div class="concept-name rd">Loss Function</div><div class="concept-def">Maps network output + ground truth to a scalar measuring prediction error. MSE for regression, cross-entropy for classification. Its geometry determines how hard training is.</div></div>
      <div class="concept-card"><div class="concept-name cy">Gradient Descent</div><div class="concept-def">The optimizer that uses backprop's output. Each step moves all weights opposite to the gradient. SGD: one sample. Mini-batch: small groups. Full-batch: all data at once.</div></div>
      <div class="concept-card"><div class="concept-name gr">Automatic Diff</div><div class="concept-def">PyTorch and JAX implement backprop via autodiff — they build a computation graph dynamically and populate gradients on backward(). You define the forward pass; you get backward for free.</div></div>
      <div class="concept-card"><div class="concept-name pu">Saddle Points</div><div class="concept-def">Points where gradient is zero but it's not a minimum — some directions curve up, others down. High-dimensional networks are dominated by saddle points. Momentum-based optimizers escape them by accumulating directional velocity.</div></div>
    </div>
  </div>
</div>

<div class="footer">
  <span>RUMELHART, HINTON, WILLIAMS — 1986 // EFFICIENT GRADIENT COMPUTATION VIA REVERSE-MODE AUTODIFF</span>
  <span>BRUTALIST TERMINAL v2 // BACKPROPAGATION</span>
</div>

<script>
const W1_INIT=[[0.5,-0.3],[0.2,0.8],[-0.6,0.4]];
const b1_INIT=[0.1,-0.1,0.2];
const W2_INIT=[0.7,-0.4,0.6];
const b2_INIT=-0.2;
const INPUT=[0.8,0.2];
const TARGET=1.0;
const LR=0.5;

function sigmoid(x){return 1/(1+Math.exp(-x));}
function relu(x){return Math.max(0,x);}
function bce(p,t){const e=1e-7;return-(t*Math.log(p+e)+(1-t)*Math.log(1-p+e));}

let state={phase:'idle',w1:W1_INIT.map(r=>[...r]),b1:[...b1_INIT],w2:[...W2_INIT],b2:b2_INIT,x:[...INPUT],z1:null,h1:null,z2:null,out:null,loss:null,dout:null,dw2:null,dh1:null,dz1:null,dw1:null};

function forwardPass(s){
  s.z1=s.w1.map((row,i)=>row[0]*s.x[0]+row[1]*s.x[1]+s.b1[i]);
  s.h1=s.z1.map(relu);
  s.z2=s.w2.reduce((a,w,i)=>a+w*s.h1[i],s.b2);
  s.out=sigmoid(s.z2);
  s.loss=bce(s.out,TARGET);
}
function backwardPass(s){
  const dl_do=-(TARGET/s.out)+(1-TARGET)/(1-s.out);
  const do_dz=s.out*(1-s.out);
  s.dout=dl_do*do_dz;
  s.dw2=s.h1.map(h=>s.dout*h);
  s.dh1=s.w2.map(w=>s.dout*w);
  s.dz1=s.dh1.map((dh,i)=>dh*(s.z1[i]>0?1:0));
  s.dw1=s.dz1.map(dz=>s.x.map(xi=>dz*xi));
}
function updateWeights(s){
  s.w2=s.w2.map((w,i)=>w-LR*s.dw2[i]);
  s.b2-=LR*s.dout;
  s.w1=s.w1.map((row,i)=>row.map((w,j)=>w-LR*s.dw1[i][j]));
  s.b1=s.b1.map((b,i)=>b-LR*s.dz1[i]);
}

const nc=document.getElementById('netCanvas');
const nctx=nc.getContext('2d');

function getPos(W,H){
  const xs=[W*0.12,W*0.5,W*0.88];
  const counts=[2,3,1];
  return counts.map((count,li)=>Array.from({length:count},(_,ni)=>({x:xs[li],y:H*0.5+(ni-(count-1)/2)*80})));
}
function hexToRgba(hex,a){
  const r=parseInt(hex.slice(1,3),16);
  const g=parseInt(hex.slice(3,5),16);
  const b=parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}

function drawNet(){
  const dpr=window.devicePixelRatio||1;
  const rect=nc.getBoundingClientRect();
  nc.width=rect.width*dpr;nc.height=rect.height*dpr;
  nctx.scale(dpr,dpr);
  const W=rect.width,H=rect.height;
  const s=state,phase=s.phase;
  nctx.fillStyle='#060606';nctx.fillRect(0,0,W,H);
  const pos=getPos(W,H);
  const fwdCol='#00ffe9',bwdCol='#ff2d55';

  pos[0].forEach((inp,ii)=>{
    pos[1].forEach((hid,hi)=>{
      const w=s.w1[hi][ii];const wabs=Math.min(Math.abs(w)*3,5);
      nctx.beginPath();nctx.moveTo(inp.x,inp.y);nctx.lineTo(hid.x,hid.y);
      if(phase==='idle'){nctx.strokeStyle='#1e1e1e';nctx.lineWidth=1;}
      else if(phase==='forward'){nctx.strokeStyle=hexToRgba(fwdCol,0.2+wabs*0.08);nctx.lineWidth=wabs;}
      else{const g=s.dw1?Math.abs(s.dw1[hi][ii])*10:0;const gabs=Math.min(g,5);nctx.strokeStyle=hexToRgba(bwdCol,0.15+gabs*0.15);nctx.lineWidth=gabs;}
      nctx.stroke();
    });
  });
  pos[1].forEach((hid,hi)=>{
    pos[2].forEach(out=>{
      const w=s.w2[hi];const wabs=Math.min(Math.abs(w)*3,5);
      nctx.beginPath();nctx.moveTo(hid.x,hid.y);nctx.lineTo(out.x,out.y);
      if(phase==='idle'){nctx.strokeStyle='#1e1e1e';nctx.lineWidth=1;}
      else if(phase==='forward'){nctx.strokeStyle=hexToRgba(fwdCol,0.2+wabs*0.08);nctx.lineWidth=wabs;}
      else{const g=s.dw2?Math.abs(s.dw2[hi])*10:0;const gabs=Math.min(g,5);nctx.strokeStyle=hexToRgba(bwdCol,0.15+gabs*0.15);nctx.lineWidth=gabs;}
      nctx.stroke();
    });
  });

  nctx.textAlign='center';
  const lnames=[['INPUT'],['HIDDEN','(ReLU)'],['OUTPUT','(sigmoid)']];
  pos.forEach((layer,li)=>{
    const lx=layer[0].x;
    const topY=Math.min(...layer.map(n=>n.y))-40;
    lnames[li].forEach((line,lni)=>{
      nctx.fillStyle='#3a3a3a';nctx.font='9px Space Mono';nctx.fillText(line,lx,topY+lni*13);
    });
  });

  const nodeLabels=[['x1','x2'],['h1','h2','h3'],['ŷ']];
  const nodeVals=[s.x,s.h1||[null,null,null],s.out!==null?[s.out]:[null]];
  pos.forEach((layer,li)=>{
    layer.forEach((node,ni)=>{
      const val=nodeVals[li][ni];
      const r=22;
      const activeColor=phase==='forward'?fwdCol:bwdCol;
      if(phase!=='idle'&&val!==null){
        const grad=nctx.createRadialGradient(node.x,node.y,r,node.x,node.y,r+16);
        grad.addColorStop(0,hexToRgba(activeColor,0.2));grad.addColorStop(1,'transparent');
        nctx.fillStyle=grad;nctx.beginPath();nctx.arc(node.x,node.y,r+16,0,Math.PI*2);nctx.fill();
      }
      nctx.beginPath();nctx.arc(node.x,node.y,r,0,Math.PI*2);
      nctx.fillStyle='#0a0a0a';nctx.fill();
      nctx.strokeStyle=phase==='idle'?'#2a2a2a':activeColor;nctx.lineWidth=phase==='idle'?1:2;nctx.stroke();
      nctx.fillStyle='#3a3a3a';nctx.font='8px Space Mono';nctx.textAlign='center';
      nctx.fillText(nodeLabels[li][ni],node.x,node.y-7);
      if(val!==null){
        nctx.fillStyle=phase==='forward'?fwdCol:bwdCol;nctx.font='bold 9px Space Mono';
        nctx.fillText(val.toFixed(3),node.x,node.y+6);
      }
    });
  });
  const phaseTxt=phase==='idle'?'AWAITING INPUT':phase==='forward'?'>>> FORWARD PASS':'<<< BACKWARD PASS';
  const phaseCol=phase==='forward'?fwdCol:phase==='backward'?bwdCol:'#3a3a3a';
  nctx.fillStyle=phaseCol;nctx.font='bold 10px Space Mono';nctx.textAlign='left';nctx.fillText(phaseTxt,10,H-10);
}

function updatePanel(){
  const s=state;const f=(v,d=4)=>v!==null?v.toFixed(d):'—';
  document.getElementById('v-x1').textContent=f(s.x[0]);
  document.getElementById('v-x2').textContent=f(s.x[1]);
  document.getElementById('v-h1pre').textContent=s.z1?f(s.z1[0]):'—';
  document.getElementById('v-h1').textContent=s.h1?f(s.h1[0]):'—';
  document.getElementById('v-h2').textContent=s.h1?f(s.h1[1]):'—';
  document.getElementById('v-h3').textContent=s.h1?f(s.h1[2]):'—';
  document.getElementById('v-out').textContent=s.out!==null?f(s.out):'—';
  document.getElementById('v-loss').textContent=s.loss!==null?f(s.loss):'—';
  document.getElementById('g-out').textContent=s.dout!==null?f(s.dout):'—';
  document.getElementById('g-w0').textContent=s.dw2?f(s.dw2[0]):'—';
  document.getElementById('g-w1').textContent=s.dw2?f(s.dw2[1]):'—';
  document.getElementById('g-w2').textContent=s.dw2?f(s.dw2[2]):'—';
  document.getElementById('g-h1').textContent=s.dh1?f(s.dh1[0]):'—';
}

document.getElementById('btnFwd').addEventListener('click',()=>{
  forwardPass(state);state.phase='forward';drawNet();updatePanel();
  document.getElementById('stepHint').textContent='Forward complete. Click BACKPROP.';
  document.getElementById('btnFwd').className='active-fwd';document.getElementById('btnBwd').className='';
});
document.getElementById('btnBwd').addEventListener('click',()=>{
  if(state.out===null)return;
  backwardPass(state);state.phase='backward';drawNet();updatePanel();
  document.getElementById('stepHint').textContent='Gradients computed. Weights would now update.';
  document.getElementById('btnBwd').className='active-bwd';document.getElementById('btnFwd').className='';
});
document.getElementById('btnReset').addEventListener('click',()=>{
  state={phase:'idle',w1:W1_INIT.map(r=>[...r]),b1:[...b1_INIT],w2:[...W2_INIT],b2:b2_INIT,x:[...INPUT],z1:null,h1:null,z2:null,out:null,loss:null,dout:null,dw2:null,dh1:null,dz1:null,dw1:null};
  drawNet();updatePanel();
  document.getElementById('stepHint').textContent='Click FORWARD to begin.';
  document.getElementById('btnFwd').className='';document.getElementById('btnBwd').className='';
});

let chainDone=false;
function revealChain(){
  if(chainDone)return;chainDone=true;
  document.querySelectorAll('.chain-line').forEach((el,i)=>{setTimeout(()=>el.classList.add('visible'),i*110);});
}
new IntersectionObserver(entries=>{entries.forEach(e=>{if(e.isIntersecting)revealChain();});},{threshold:0.2}).observe(document.getElementById('chainContainer'));

const lc=document.getElementById('lossCanvas');
const lctx=lc.getContext('2d');
let lossHistory=[],trainState=null,trainInterval=null,trainEpoch=0;

function drawLoss(){
  const dpr=window.devicePixelRatio||1;
  const rect=lc.getBoundingClientRect();
  lc.width=rect.width*dpr;lc.height=rect.height*dpr;
  lctx.scale(dpr,dpr);
  const W=rect.width,H=rect.height;
  lctx.fillStyle='#060606';lctx.fillRect(0,0,W,H);
  for(let i=0;i<=4;i++){
    const y=(H-20)*(i/4)+10;
    lctx.strokeStyle='#1a1a1a';lctx.lineWidth=1;
    lctx.beginPath();lctx.moveTo(32,y);lctx.lineTo(W-8,y);lctx.stroke();
    lctx.fillStyle='#3a3a3a';lctx.font='8px Space Mono';lctx.textAlign='right';
    lctx.fillText((1-i/4).toFixed(1),28,y+3);
  }
  if(lossHistory.length<2)return;
  lctx.beginPath();
  lossHistory.forEach((loss,i)=>{
    const x=32+(i/200)*(W-42);const y=10+(1-Math.min(loss,1.0))*(H-20);
    i===0?lctx.moveTo(x,y):lctx.lineTo(x,y);
  });
  lctx.strokeStyle='#ff2d55';lctx.lineWidth=2;lctx.stroke();
  lctx.shadowColor='#ff2d55';lctx.shadowBlur=8;
  lctx.beginPath();
  lossHistory.forEach((loss,i)=>{
    const x=32+(i/200)*(W-42);const y=10+(1-Math.min(loss,1.0))*(H-20);
    i===0?lctx.moveTo(x,y):lctx.lineTo(x,y);
  });
  lctx.stroke();lctx.shadowBlur=0;
  const last=lossHistory.length-1;
  const lx=32+(last/200)*(W-42);const ly=10+(1-Math.min(lossHistory[last],1.0))*(H-20);
  lctx.beginPath();lctx.arc(lx,ly,4,0,Math.PI*2);lctx.fillStyle='#ff2d55';lctx.fill();
}

document.getElementById('btnTrain').addEventListener('click',()=>{
  if(trainInterval)return;
  trainState={w1:W1_INIT.map(r=>[...r]),b1:[...b1_INIT],w2:[...W2_INIT],b2:b2_INIT,x:[...INPUT]};
  lossHistory=[];trainEpoch=0;
  trainInterval=setInterval(()=>{
    if(trainEpoch>=200){clearInterval(trainInterval);trainInterval=null;document.getElementById('finalPred').textContent=trainState.out?trainState.out.toFixed(4):'—';return;}
    forwardPass(trainState);backwardPass(trainState);updateWeights(trainState);
    lossHistory.push(trainState.loss);trainEpoch++;
    document.getElementById('epochBar').style.width=(trainEpoch/200*100)+'%';
    document.getElementById('epochLabel').textContent=`Epoch ${trainEpoch} / Loss: ${trainState.loss.toFixed(4)}`;
    drawLoss();
  },18);
});
document.getElementById('btnResetTrain').addEventListener('click',()=>{
  if(trainInterval){clearInterval(trainInterval);trainInterval=null;}
  lossHistory=[];trainEpoch=0;
  document.getElementById('epochBar').style.width='0%';
  document.getElementById('epochLabel').textContent='—';
  document.getElementById('finalPred').textContent='—';
  drawLoss();
});

window.addEventListener('load',()=>{drawNet();updatePanel();drawLoss();});
window.addEventListener('resize',()=>{drawNet();drawLoss();});
</script>
</body>
</html>
